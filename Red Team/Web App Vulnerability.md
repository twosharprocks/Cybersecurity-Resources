# General
[Portswigger - Pentesting Workflow](https://portswigger.net/burp/documentation/desktop/testing-workflow)
[OWASP Webv Application Security Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/)

[Top 5 Website PenTesting Tools](https://thegrayarea.tech/the-top-5-bug-bounty-hunting-automation-tools-550510423454)
   - [Brute Forcing Websites with Hydra](https://infinitelogins.com/2020/02/22/how-to-brute-force-websites-using-hydra/)
   - [How to Hack Web Apps](https://null-byte.wonderhowto.com/how-to/hack-like-pro-hack-web-apps-part-1-getting-started-0159914/)
   - [Payloads All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings)
   - [Command Injection Cheatsheet - Comprehensive](https://hackersonlineclub.com/command-injection-cheatsheet/)
   - [Web App Vulnerabilities Reference](https://brightsec.com/blog/web-application-vulnerabilities/)
   - [Big List of Naughty Strings](https://github.com/minimaxir/big-list-of-naughty-strings)

[Cybersecurity Handbook](https://guidesmiths.github.io/cybersecurity-handbook/) - Focussed on the [OWASP Top 10](https://owasp.org/www-project-top-ten/)

[OWASP Top Ten (2021)](https://owasp.org/www-project-top-ten/)
- A01:2021-Broken Access Control
- A02:2021-Cryptographic Failures
- A03:2021-Injection
- A04:2021-Insecure Design
- A05:2021-Security Misconfiguration
- A06:2021-Vulnerable and Outdated Components 
- A07:2021-Identification and Authentication Failures
- A08:2021-Software and Data Integrity Failures
- A09:2021-Security Logging and Monitoring Failures 
- A10:2021-Server-Side Request Forgery

## SQL Injection (SQLi) [A03:2021-Injection]
SQL vulnerabilities allow attackers to insert malicious SQL commands to exfiltrate, modify, or delete data. Some hackers use SQL to gain root access to the target system. The most common vulnerability is using unsanitized user inputs. Strip out any element in user-supplied inputs that the server could execute as SQL code by using [Prepared Statements](https://www.w3schools.com/php/php_mysql_prepared_statements.asp).

* Types
   * Basic: Input and return database info
   * Blind: No database info is returned, but page behaviour is changed
   * Time-Based or “Super Blind”: Nothing is different returned, but the time to response is different

* UNION statements [Portswigger Explainer](https://portswigger.net/web-security/sql-injection/union-attacks)
* Sub-queries (searching WHERE clause with wildcards) 
* Sub-strings (using &lt; & > to conduct a binary search)

* [PortSwigger - SQL injection cheat sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)
        * ‘OR 1=1
        * ‘AND 1=2 
* [MSSQL Injection Cheat Sheet](https://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet) - MSSQL queries, and includes links to cheat sheets for Oracle, MySQL, PostgresSQL, Ingres, DB2, Informix and Ms Access

## Cross-site scripting (XSS) [A03:2021-Injection]
XSS attacks are similar to SQL injection attacks and involve the injection of malicious scripts into websites or web applications. The point of difference is that the malicious code runs in the browser only when the user visits a compromised website or app. Attackers often carry out XSS attacks by injecting code into input fields that the target page runs when visitors view the page (e.g., embedded JavaScript link).
    * [XSS Filter Evasion Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
    * [XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
    * XSS Types
        * Reflected XSS - “Fire & Forget"
           * [Multi-Reflection XSS Generator](https://codepen.io/karelorigin/pen/jOzLOqg)
        * Stored XSS - Triggers every time data is loaded, may transit between apps
        * Document Object Model (DOM) XSS - Difficult to detect & may not render
    * [What is Cross-Site Scripting (XSS) and how to prevent it?](https://portswigger.net/web-security/cross-site-scripting)
          * Can you input unencoded JavaScript for any available input field, and is this input returned to a web browser or executed at any point?
          * GET Requests? POST Requests?
          * Can you include references to JavaScript from unexpected or unauthorised locations?
          * Validate Input Is it a string of length x?
    * Sanitise Input: Removes harmful characters or content from input. The process cannot be reversed and need to be careful (such as for special characters from names). Harmful characters may include white space, &lt;/
    * Encoding Input: Transforms data from one format to another eg. ASCII to base64. Encoding should occur when processed or displayed. It’s important to consider the ENTIRE lifetime of the data (eg. malicious script is hidden in a process but executes when an HTML report is generated at the end of the month)
    * Content Security Policy: Checks headers against a broad policy and only renders if the content meets that policy.
        * All inline JavaScript must be moved from pages to external reference files
        * Specify policy and define permitted locations for scripts, images, fonts & media
        * Test the policy and monitor the console for errors & violations. Make the most of the _learning mode_ before implementing _enforcing mode_
        * [Bypassing Content Security Policy](https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass)

## * XML Extern Entity (XXE) Vulnerabilities 
An XXE attack is a type of attack against an application that parses XML input. 
* XXE Mitigation
    * Do you NEED to parse XML? Sanitising XML is difficult
        * Always sanitise untrusted XML input
    * Disable Document Type Declaration processing in your XML Parser
    * Consider secure architectural patterns
    * [XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)
    * [XXE Cheat Sheety (GitHub)](https://github.com/payloadbox/xxe-injection-payload-list)

## Cross-Site Request Forgery (CSRF) 
A CSRF attack occurs when an attacker forces the victim to perform unintended actions on the web application. The victim first logs into the web app, which has deemed the user and browser trustworthy. Therefore, the app will execute malicious actions that the attacker tricks the victim into forwarding a request to the web app. The motivation for CSRF ranges from simple pranks to enabling illicit financial transactions.

## Session Fixation
A session fixation attack involves forcing a user’s session ID to a specified value. Depending on the target web application’s functionality, attackers may use various techniques to fix session ID values. Examples of session fixation techniques include cross-site scripting exploits and reusing HTTP requests. First, an attacker fixes the victim’s user session ID. Then, the user logs in and inadvertently exposes the online identity. The attacker can then hijack the victim’s user identity using the fixed session ID value. Any web application that authenticates users with sessions is vulnerable to session fixation attacks without adequate defenses. Web apps that use session IDs typically use cookies, though they can also use hidden form fields or URLs. Cookie-based user sessions are the most popular and the easiest to compromise. Most fixation attacks target cookie-based sessions. 

## Path/Directory Traversal
Path traversal attacks, or backtracking, involve exploiting how the web application receives data from a web server. Web apps often use Access Control Lists (ACLs) to restrict user access to specific files within the root directory. A malicious actor can identify the URL format the target application uses for file requests.
   * [OWASP Path Traversal (with examples)](https://owasp.org/www-community/attacks/Path_Traversal#) 

## Local File Inclusion 
An LFI attack exploits the dynamic file inclusion mechanisms in a web application. It may occur when a web application takes user input, such as a parameter value or URL, and passes it to a file inclusion command. An attacker can use this mechanism to trick the app into including a remote file containing malicious code. 
   * [LFI - Aptive.co.uk](https://www.aptive.co.uk/blog/local-file-inclusion-lfi-testing) - Examples and security testing for LFI vulnerabilities
 
Most web application frameworks enable file inclusion, which is useful primarily to package shared code into different files for later reference by the application’s main modules. If a web app references a file for inclusion, it might execute the code in the file explicitly or implicitly (i.e., by calling a specific procedure). The application could be vulnerable to LFI attacks if the module-to-load choice is based on HTTP request elements. 

## Security Misconfigurations [A05:2021-Security Misconfiguration] 
Security misconfigurations are some of the most serious web application vulnerabilities because they provide attacks with opportunities to infiltrate the application easily. Attackers could exploit a wide range of security configuration vulnerabilities. These include unchanged default configurations, data stored in the cloud, ad hoc or incomplete configurations, plaintext error messages containing sensitive information, and HTTP header misconfigurations. Security misconfigurations may be present in any operating system, library, framework, or application.  

## XML External Entity (XEE) Processing [A05:2021-Security Misconfiguration] 
An XXE attack occurs when an attacker abuses widely used features in XML parsers to gain access to remote or local files, typically resulting in Denial of Service (DoS). Attackers can also use XXE processing to carry out SSRF attacks, which force the web application to make external, malicious requests. XXE can also enable attackers to scan ports and execute malicious code remotely.
